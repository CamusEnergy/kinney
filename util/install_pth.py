"""This script writes a `*.pth` ([1]) file to the site-packages directory that
injects a synthetic PEP 420 Namespace Package ([2]) into the module cache,
allowing representing a directory as a Namespace Package without having to
conform to the strict directory layout requirements outlined in PEP 420.  In
particular, this mimics the `package_dir={'<package_name>':''}` behavior ([3]
and [4]) for local development, which is not supported by setuptools's
"development mode" ([5]).

[1]: https://docs.python.org/3.7/library/site.html
[2]: https://www.python.org/dev/peps/pep-0420/
[3]: https://docs.python.org/3.7/distutils/examples.html#pure-python-distribution-by-package
[4]: https://docs.python.org/3.7/distutils/setupscript.html#listing-whole-packages
[5]: https://setuptools.readthedocs.io/en/latest/setuptools.html#development-mode
"""
import argparse
import os.path
import sysconfig

# This is the format-string template for the generated `.pth` file.  All empty
# lines and lines beginning with "#" will be stripped, with the remaining lines
# being joined by a semicolon to produce a single line of valid Python that
# begins with the keyword "import":
# https://docs.python.org/3.7/library/site.html
PTH_TEMPLATE = """
import importlib.machinery
import importlib.util
import sys

# https://docs.python.org/3/library/importlib.html#importlib.machinery.ModuleSpec
# * `loader` should be `None` for namespace packages.
# * `origin` is the place from which the module is loaded, and maybe `None` (the
#   default) if it is unspecified, as is the case in namespace packages.
# * `is_package=True` sets `self.submodule_search_locations` to an empty list.
#   This is subsequently overwritten, but is specified here for clarity, as this
#   `ModuleSpec` describes a namespace package.
#
# Note that this line can not be broken, as the naive semicolon-based
# line-joining would result in invalid sytanx in the output.
spec = importlib.machinery.ModuleSpec(name='{package_name}', loader=None, is_package=True)

# Set the list of directories which should be searched for submodules to the
# package root.
spec.submodule_search_locations = ['{package_root}']

# Turn the module spec for the synthatic Namespace Package into a module
# instance, and add it to the module cache so that import resolution will begin
# with this module for any package whose import path begins with
# '{package_name}', short-circuiting the default module search process:
# https://docs.python.org/3.7/reference/import.html#searching
sys.modules['{package_name}'] = importlib.util.module_from_spec(spec)
"""

# The first line of the output file, indicating that the file is generated code,
# and providing a reference to the generator.
OUTPUT_PREFIX = '# DO NOT MODIFY: Generated by `util/install_pth.py`'


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--package_name',
        required=True,
        help='The name of the PEP 420 Namespace Package to generate.')
    parser.add_argument(
        '--package_root',
        required=True,
        help=('The directory that should be used as the root of the generated '
              'PEP 420 Namespace Package.'))
    args = parser.parse_args()

    # Evaluate the template, filling in the package name and location.
    params = {
        'package_name': args.package_name,
        'package_root': os.path.abspath(args.package_root),
    }
    content = PTH_TEMPLATE.format(**params)

    # Split the content into lines, and strip out any blank lines, and any
    # comment lines.
    lines = [l for l in content.splitlines() if l and not l.startswith('#')]

    # Join all of the remaining lines with semicolons in order to produce a
    # valid single line of Python code, prefixing the output with the "generated
    # file" warning.
    output = OUTPUT_PREFIX + '\n' + ';'.join(lines)

    # Get the virtual environment's site-packages directory.  This can not use
    # `site.getsitepackages()`, since that does not work in a venv, so we use
    # the "purelib" directory instead, which should be the same.
    #
    # https://stackoverflow.com/questions/122327/how-do-i-find-the-location-of-my-python-site-packages-directory/46071447#46071447
    # https://docs.python.org/3/library/sysconfig.html#installation-paths
    site_packages_dir = sysconfig.get_path('purelib')

    # Write the output to a '*.pth' file in the site-packages directory
    # directory named after the package name.
    basename = args.package_name + '.pth'
    output_filename = os.path.join(site_packages_dir, basename)
    with open(output_filename, 'w') as fp:
        fp.write(output)


if __name__ == '__main__':
    main()
